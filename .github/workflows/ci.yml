name: CI/CD

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]
  workflow_dispatch:

env:
  LLVM_VERSION: 18

jobs:
  build-and-test:
    name: Build and Test (${{ matrix.os }}, ${{ matrix.build_type }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        build_type: [Release, Debug]
        include:
          - os: ubuntu-latest
            llvm_install: |
              wget https://apt.llvm.org/llvm.sh
              chmod +x llvm.sh
              sudo ./llvm.sh 18
              sudo apt-get install -y llvm-18-dev libclang-18-dev
          - os: macos-latest
            llvm_install: |
              brew install llvm@18
              echo "LLVM_DIR=$(brew --prefix llvm@18)/lib/cmake/llvm" >> $GITHUB_ENV
          - os: windows-latest
            llvm_install: |
              Write-Host "Checking for existing LLVM installation..."
              
              # First check if llvm-config is in PATH
              $llvmConfig = Get-Command llvm-config -ErrorAction SilentlyContinue
              if ($llvmConfig) {
                $llvmPath = Split-Path (Split-Path $llvmConfig.Source)
                Write-Host "Found LLVM in PATH at: $llvmPath"
                $version = & llvm-config --version
                Write-Host "LLVM version: $version"
              } else {
                # Check common installation paths
                $possiblePaths = @(
                  "C:\Program Files\LLVM",
                  "C:\Program Files (x86)\LLVM",
                  "C:\hostedtoolcache\windows\LLVM"
                )
                
                $llvmPath = $null
                foreach ($path in $possiblePaths) {
                  if (Test-Path "$path\bin\llvm-config.exe") {
                    $llvmPath = $path
                    Write-Host "Found LLVM at: $llvmPath"
                    break
                  }
                }
                
                # If still not found, install it
                if (-not $llvmPath) {
                  Write-Host "LLVM not found. Installing via Chocolatey..."
                  choco install llvm -y --no-progress
                  
                  # Wait for installation to complete
                  Start-Sleep -Seconds 10
                  
                  # Refresh environment and check again
                  $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
                  
                  $llvmConfig = Get-Command llvm-config -ErrorAction SilentlyContinue
                  if ($llvmConfig) {
                    $llvmPath = Split-Path (Split-Path $llvmConfig.Source)
                  } else {
                    $llvmPath = "C:\Program Files\LLVM"
                  }
                  
                  Write-Host "LLVM installed at: $llvmPath"
                }
              }
              
              # Verify the installation
              if (Test-Path "$llvmPath\bin\llvm-config.exe") {
                $version = & "$llvmPath\bin\llvm-config.exe" --version
                Write-Host "Successfully configured LLVM version: $version"
              } else {
                Write-Host "ERROR: LLVM installation verification failed"
                exit 1
              }
              
              # Set environment variables for subsequent steps
              echo "LLVM_DIR=$llvmPath\lib\cmake\llvm" | Out-File -FilePath $env:GITHUB_ENV -Append
              echo "LLVM_ROOT=$llvmPath" | Out-File -FilePath $env:GITHUB_ENV -Append
              echo "$llvmPath\bin" | Out-File -FilePath $env:GITHUB_PATH -Append

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Cache LLVM
      id: cache-llvm
      uses: actions/cache@v4
      with:
        path: |
          ~/.llvm
          ~/Library/Caches/Homebrew/llvm*
          C:\Program Files\LLVM
        key: ${{ runner.os }}-llvm-${{ env.LLVM_VERSION }}

    - name: Install LLVM (Unix)
      if: runner.os != 'Windows'
      run: ${{ matrix.llvm_install }}
      shell: bash

    - name: Install LLVM (Windows)
      if: runner.os == 'Windows'
      run: ${{ matrix.llvm_install }}
      shell: pwsh

    - name: Verify LLVM Installation (Windows)
      if: runner.os == 'Windows'
      run: |
        Write-Host "Verifying LLVM installation..."
        Write-Host "LLVM_ROOT: $env:LLVM_ROOT"
        Write-Host "LLVM_DIR: $env:LLVM_DIR"
        
        if (Test-Path "$env:LLVM_ROOT\bin\llvm-config.exe") {
          Write-Host "LLVM found at: $env:LLVM_ROOT"
          & "$env:LLVM_ROOT\bin\llvm-config.exe" --version
          Write-Host "CMake config path: $env:LLVM_DIR"
          
          if (Test-Path "$env:LLVM_DIR\LLVMConfig.cmake") {
            Write-Host "âœ“ LLVMConfig.cmake found!"
          } else {
            Write-Host "WARNING: LLVMConfig.cmake not found at expected location"
            Write-Host "Searching for LLVM CMake files..."
            if (Test-Path "$env:LLVM_ROOT\lib\cmake") {
              Get-ChildItem "$env:LLVM_ROOT\lib\cmake" -Recurse -Filter "LLVM*.cmake" | Select-Object -First 10 | ForEach-Object { Write-Host $_.FullName }
            }
          }
        } else {
          Write-Host "ERROR: LLVM not found at $env:LLVM_ROOT"
          exit 1
        }
      shell: pwsh

    - name: Configure CMake
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} -DCMAKE_PREFIX_PATH="C:/Program Files/LLVM" -DBUILD_TESTING=ON -DBUILD_EXAMPLES=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
          cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} -DBUILD_TESTING=ON -DBUILD_EXAMPLES=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        fi
      shell: bash

    - name: Build
      run: cmake --build build --config ${{ matrix.build_type }} --parallel

    - name: Run tests
      run: ctest --test-dir build --build-config ${{ matrix.build_type }} --output-on-failure --verbose || echo "No tests defined yet"
      continue-on-error: true

    - name: Upload test results
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}-${{ matrix.build_type }}
        path: build/Testing/Temporary/
        retention-days: 7

  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        wget https://apt.llvm.org/llvm.sh
        chmod +x llvm.sh
        sudo ./llvm.sh 18
        sudo apt-get install -y \
          clang-format-18 \
          clang-tidy-18 \
          llvm-18-dev \
          libclang-18-dev

    - name: Check clang-format
      run: |
        find src include tests examples -type f \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" \) \
          | xargs clang-format-18 --dry-run --Werror -style=file

    - name: Configure CMake for clang-tidy
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_COMPILER=clang++-18

    - name: Run clang-tidy
      run: |
        find src include -type f \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" \) \
          | xargs clang-tidy-18 -p build --warnings-as-errors='*'

    - name: Upload compile_commands.json
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: compile-commands
        path: build/compile_commands.json
        retention-days: 7

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    permissions:
      security-events: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: cpp

    - name: Install LLVM
      run: |
        wget https://apt.llvm.org/llvm.sh
        chmod +x llvm.sh
        sudo ./llvm.sh 18
        sudo apt-get install -y llvm-18-dev libclang-18-dev

    - name: Build for CodeQL
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release
        cmake --build build

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        wget https://apt.llvm.org/llvm.sh
        chmod +x llvm.sh
        sudo ./llvm.sh 18
        sudo apt-get install -y \
          llvm-18-dev \
          libclang-18-dev \
          lcov

    - name: Configure CMake with coverage
      run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER=clang-18 -DCMAKE_CXX_COMPILER=clang++-18 -DCMAKE_CXX_FLAGS="--coverage" -DCMAKE_C_FLAGS="--coverage" -DBUILD_TESTING=ON

    - name: Build with coverage
      run: cmake --build build

    - name: Run tests
      run: ctest --test-dir build --output-on-failure

    - name: Create gcov wrapper
      run: |
        echo '#!/bin/bash' > gcov-wrapper.sh
        echo 'exec llvm-cov-18 gcov "$@"' >> gcov-wrapper.sh
        chmod +x gcov-wrapper.sh

    - name: Generate coverage report
      run: |
        lcov --gcov-tool ./gcov-wrapper.sh --directory build --capture --output-file coverage.info --ignore-errors inconsistent,inconsistent --rc lcov_branch_coverage=1
        lcov --gcov-tool ./gcov-wrapper.sh --remove coverage.info '/usr/*' '*/tests/*' '*/examples/*' '*/_deps/*' '*/build/*' --output-file coverage.info
        lcov --list coverage.info

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        files: ./coverage.info
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: false

  documentation:
    name: Build Documentation
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Doxygen
      run: sudo apt-get install -y doxygen graphviz

    - name: Generate documentation
      run: |
        if [ -f "Doxyfile" ]; then
          doxygen Doxyfile
        else
          echo "No Doxyfile found, skipping documentation generation"
        fi

    - name: Deploy to GitHub Pages
      if: success()
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs/html
        publish_branch: gh-pages

  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [build-and-test, code-quality, security-scan]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install LLVM
      run: |
        wget https://apt.llvm.org/llvm.sh
        chmod +x llvm.sh
        sudo ./llvm.sh 18
        sudo apt-get install -y llvm-18-dev libclang-18-dev

    - name: Build Release
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_EXAMPLES=ON
        cmake --build build

    - name: Package artifacts
      run: |
        cd build
        cpack -G "TGZ;ZIP"

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: build/*.tar.gz,build/*.zip
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify:
    name: Notification
    runs-on: ubuntu-latest
    if: always()
    needs: [build-and-test, code-quality, security-scan]

    steps:
    - name: Check workflow status
      run: |
        if [ "${{ needs.build-and-test.result }}" != "success" ] || \
           [ "${{ needs.code-quality.result }}" != "success" ] || \
           [ "${{ needs.security-scan.result }}" != "success" ]; then
          echo "WORKFLOW_FAILED=true" >> $GITHUB_ENV
        else
          echo "WORKFLOW_FAILED=false" >> $GITHUB_ENV
        fi

    - name: Send status notification
      if: needs.build-and-test.result != 'success' || needs.code-quality.result != 'success' || needs.security-scan.result != 'success'
      run: |
        echo "::warning::CI/CD workflow encountered failures. Please review the logs."